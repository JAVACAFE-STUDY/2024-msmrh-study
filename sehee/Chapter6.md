# 전역 상태를 설계할 때의 주의사항

### 전역 상태를 읽는 방법

앞서 context의 문제점과 같이, 전역 상태가 바뀌면 해당 값이 컴포넌트와 관련 없는 경우에도 리렌더링이 발생한다.

전역 상태 라이브러리는 이러한 불필요한 리렌더링을 피하는 해결책을 제공할 필요가 있다.

### 전역 상태에 값을 넣거나 갱신하는 방법

전역 상태가 중첩된 객체일 경우, 하나의 전역 변수를 가지고 개발자가 직접 값을 변경하는 것은 좋지 않다.

ex) globalVariable.b.d = 9

⇒ 변경 사항을 감지하고 컴포넌트를 리렌더링할 방법이 없기 때문.

전역 상태 라이브러리는 전역 상태를 변경하는 함수를 제공해야 한다.

# 범용 상태 vs 전역 상태

이 책에서는 Redux나 XState를 범용 상태로 분류하고 다루지 않는다.

# 데이터 중심 접근 방식과 컴포넌트 중심 접근 방식 사용하기

전역 상태는 데이터 중심과 컴포넌트 중심 유형으로 나눌 수 있다.

## 데이터 중심 접근 방식

처리할 데이터가 이미 있는 경우의 접근 방식. 컴포넌트를 싱글턴 데이터 모델과 연결한다.

모듈 상태를 사용하는 편이 적합하다. (모듈 상태가 리액트 외부의 자바스크립트 메모리에 있기 때문)

모듈 상태는 리액트가 렌더링을 시작하기 전이나, 모든 리액트 컴포넌트가 마운트 해제된 후에도 존재할 수 있다.

데이터 중심 접근 방식을 사용하는 전역 상태 라이브러리는 모듈 상태를 생성하고 모듈 상태를 리액트 컴포넌트에 연결하는 API를 제공한다.

## 컴포넌트 중심 접근 방식

컴포넌트를 먼저 설계하는 접근 방식. 데이터 모델이 컴포넌트에 강한 의존성을 가진다.

컴포넌트 생명 주기 내에서 전역 상태를 유지하는 것이 적합하다. (컴포넌트가 모두 마운트 해제되면 전역 상태도 함께 사라지기 때문)

이를 활용하여 자바스크립트 메모리에 두 개 이상의 동일한 전역 상태를 둘 수 있다. (서로 다른 컴포넌트 하위 트리에 존재)

컴포넌트 중심 접근 방식을 사용하는 전역 상태 라이브러리는 리액트 컴포넌트에서 사용할 전역 상태를 초기화하는 팩토리 함수를 제공한다.

# 두 접근 방식의 예외

두 가지 접근 방식은 상충되는 것이 아니며, 둘을 함께 사용할 수도 있다.

모듈 상태는 대체로 싱글턴 패턴으로 구현되지만 하위 트리에 대해 여러 모듈 상태를 만들 수도 있다.

컴포넌트 상태는 대체로 useState로 구현되지만 변경 가능한 변수나 store가 필요한 경우 useRef 훅으로도 구현할 수 있다.

# 리렌더링 최적화

리렌더링 최적화의 핵심은 컴포넌트에서 state의 어느 부분이 사용될지 지정하는 것이다.

state의 일부분을 지정하는 접근 방식에는 다음과 같은 것들이 있다.

- 선택자 함수 사용
- 속성 접근 감지
- 아톰 사용

## 선택자 함수 사용(수동 렌더링 최적화)

선택자 함수는 상태를 받아 상태의 일부를 반환한다. 다음의 useSelector와 같이 사용한다.

```jsx
const Component = () => {
  const value = useSelector((state) => state.b.c);
  return <>{value}</>;
};
```

useSelector는 상태가 변경될 때마다 선택자 함수의 결과를 비교하는 데 사용된다.

⇒ 선택자 함수는 동일한 입력이 주어졌을 때 state를 참조해서 동일한 결과를 반환해야 한다.

선택자 함수는 매우 유연해서 상태에서 파생된 값(ex: state.b.c \* 2)도 동일하게 반환한다.

<aside>
💡

선택자 함수가 파생된 객체 값을 반환할 경우, 메모이제이션을 사용해 동일한 객체를 반환하도록 해야 한다.

</aside>

선택자 함수는 컴포넌트의 어느 부분을 사용할지 명시적으로 지정하는 방법이므로 수동 최적화라고 한다.

## 속성 접근 감지(자동 렌더링 최적화)

컴포넌트에서 속성 접근을 감지하고 감지한 정보를 렌더링 최적화에 사용할 수 있는 상태 사용 추적(state usage tracking)이라는 것이 있다.

다음의 useTrackedState와 같이 사용한다.

```jsx
const Component = () => {
  const trackedState = useTrackedState();
  return <p>{trackedState.b.c}</p>;
};
```

위의 trackedState는 하위 속성에 접근했을 때 이를 감지할 수 있고, 속성값이 변경될 때 useTrackedState가 리렌더링을 발생시킨다. (자동 렌더링 최적화)

useTrackedState를 구현하려면 상태 객체에 대한 속성 접근을 확인하기 위한 프락시가 필요하다.

<aside>
💡

`Proxy` : 한 객체에 대한 기본 작업을 가로채고 재정의하는 프록시를 만들 수 있는 객체.

</aside>

### 자동 렌더링 최적화의 한계

useSelector는 파생 값에도 동일하게 반환하므로 상태를 더 간단한 값으로 만들 수 있지만, useTrackedState를 파생값을 동일하게 인식하지 못하고 리렌더링을 유발한다.

## 아톰 사용

아톰 : 리렌더링을 발생시키는 데 사용되는 최소 상태 단위.

아톰을 사용하면 전역 상태를 세분화해서 구독하는 것이 가능하다.

다음과 같이 atom 함수를 통해 아톰을 생성하고, useAtom 훅을 사용해서 아톰만 구독한다.

```jsx
const globalState = {
  a: atom(1),
  b: atom(2),
  c: atom(3),
};

const Component = () => {
  const value = useAtom(globalState.a);
  return <>{value}</>;
};
```

아톰은 수동 최적화와 자동 최적와의 중간 정도로 볼 수 있다.

(아톰과 파생값의 정의는 명시적이지만 의존성 추적은 자동으로 된다.)
