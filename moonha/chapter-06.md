## 전역 상태 관리 문제 해결하기

- 전역 상태를 설계할 때는 아래 두 가지 문제점이 발생할 수 있음
    - **전역 상태를 읽는 방법**
    - **전역 상태에 값을 넣거나 갱신하는 방법**
        - 불변성을 고려해야 함
        - **전역 상태를 변경하는 함수를 제공해야 함**

## 데이터 중심 접근 방식과 컴포넌트 중심 접근 방식 사용하기

### **데이터 중심 접근 방식**

- 리액트 외부에서 상태를 관리하며, 상태가 리액트 생명 주기와 독립적.
- 리액트 외부에서도 상태를 쉽게 접근하고 갱신할 수 있음

### **컴포넌트 중심 접근 방식**

- 리액트 컴포넌트 내에서 전역 상태를 관리
- 컴포넌트 생명 주기와 강하게 연결되어 있음
- `Context`를 이용한 상태 관리가 대표적

## 두 접근 방식의 예외

- 모듈 상태
    - 대체로 싱글턴 패턴으로 구현되지만 하위 트리에 대해 여러 모듈 상태를 만들 수도 있음
        
        → 특정 하위 트리(예: 페이지나 특정 컴포넌트)에 대해 독립적인 상태가 필요할 경우 여러 개의 모듈 상태를 만들 수도 있음
        
    - 심지어 모듈 상태의 생명주기를 제어할 수도 있음
        
        → 모듈 상태는 컴포넌트와 독립적으로 관리되므로, 상태의 생명주기를 세밀하게 제어할 수 있음. 필요에 따라 언제 상태를 생성하거나 제거할지 정의할 수 있음
        
    - 하위 트리에 상태를 제공하기 위해 컴포넌트 상태가 사용되기도 함
        
        → 때로는 하위 컴포넌트 트리에게 상태를 제공하기 위해 컴포넌트 상태(즉, `useState`나 `useReducer` 등)를 사용할 수 있음. 예를 들어, 모듈 상태를 제공하는 공급자(provider) 컴포넌트를 트리의 최상위에 두고 하위 컴포넌트가 그 상태를 참조하게 하는 방식
        
        - 공급자 컴포넌트를 트리의 최상위에 두고 트리가 하나만 있으면 사실상 싱글턴 패턴이라고 볼 수 있음
- 컴포넌트 상태
    - 대체로 useState 훅으로 구현되지만 변경 가능한 변수나 store가 필요한 경우 useRef 훅으로도 구현이 가능함
        
        → 단순히 리렌더링을 일으키지 않고 컴포넌트 안에서 값을 변경해야 하는 경우 `useRef`를 사용할 수 있음. 예를 들어, 타이머나 DOM 요소의 참조를 유지할 때처럼 리렌더링에 의존하지 않고 상태를 보존해야 할 때 `useRef`가 유용함
        
    - 구현은 복잡할 수도 있지만, 여전히 컴포넌트 생명 주기에 포함됨

## 리렌더링 최적화

- 리렌더링 최적화의 핵심은 컴포넌트에서 state의 어느 부분이 사용될 지 지정하는 것

### 선택자 함수 사용

- 상태를 받아 상태의 일부를 반환함
    
    ```tsx
    const Component = () => {
    	const value = useSelector((state) => state.b.c);
    	...
    };
    ```
    
    - 해당 컴포넌트가 state.b.c에만 관심이 있다는 것을 알고 있으므로 state.a가 변경된 경우에는 리렌더링을 피해야 함
- useSelector는 **상태가 변경될 때마다 선택자 함수의 결과를 비교하는데 사용됨**
    - 선택자 함수는 동일한 입력이 주어졌을 때 state를 참조해서 동일한 경과를 반환하는 것이 중요함
- 선택자 함수는 매우 유연해서 상태의 일부뿐만 아니라 **파생된 값도 반환할 수 있음**
    
    ```tsx
    const value = useSelector((state) => state.b.c * 2);
    ```
    
    - 선택자 함수가 파생된 객체 값을 반환하는 경우에는 메모이제이션을 사용해 동일한 객체가 반환하도록 해야 함
- **컴포넌트의 어느 부분을 사용할지 명시적으로 지정하는 방법이므로 이를 수동 최적화라고 함**

### 속성 접근 감지

- 상태 사용 추적(state usage tracking)
    - 속성 접근을 감지하고 감지한 정보를 렌더링 최적화를 자동으로 수행

```tsx
const Component = () => {
	const trackedState = useTrackedState();

	return <p>{trackedState.b.c.}</p>;
};
```

- trackedState가 .b.c 속성에 접근했음을 감지할 수 있고 .b.c 속성 값이 변경될 때만 useTrackedState가 리렌더링을 발생시킴
- **자동 렌더링 최적화임**
- useTrackedState를 구현하려면 상태 객체에 대한 속성 접근을 확인하기 위한 프락시(proxy)가 필요
- 자동 렌더링 최적화가 완벽하게 작동하지 않는 경우도 있음

**useSelector와 useTrackedState의 차이점**

- useSelector는 파생 값을 만들 수 있기 때문에 상태를 더 간단한 값으로 만들 수 있음
    
    ```tsx
    const Component = () => {
    	const isSmall = useSelector((state) =. state.a < 10);
    	
    	return <>{isSmall ? 'small' : 'big'}</>
    };
    ```
    
    ```tsx
    const Component = () => {
    	const isSmall = useTrackedState().a < 10;
    	
    	return <>{isSmall ? 'small' : 'big'}</>
    };
    ```
    
    - useTrackedState
        - state.a가 변경될 때마다 리렌더링 됨
    - useSelector
        - isSmall이 변경될 때만 리렌더링되어 최적화가 더 잘 됨

### 아톰 사용

- 아톰
    - **리렌더링을 발생시키는 데 사용되는 최소 상태 단위**
- 좀 더 세분화해서 구독하는 것이 가능

```tsx
const globalState = {
	a: atom(1),
	b: atom(2),
	c: atom(3),	
};

const Component = () => {
	const value = useAtom(globalState.a);
	
	return <>{value}</>
};
```

- 아톰이 완전히 분리돼 있다면 별도의 전역 상태를 갖는 거의 같다고 볼 수 있음
- 아틈으로 파생값을 만들 수 있음
    
    ```tsx
    const sum = globalState.a. + globalState.b. + globalState.c;
    ```
    
    - 위 작업을 수행하기 위해서는 의존성을 추적해서 아톰이 갱신될 때마다 파생 값을 다시 평가해야 함
    - 8장 Jotai 참고
- 수동 최적화와 자동 최적화의 중간 정도
    - **아톰과 파생 값의 정의는 명시적이지만, 의존성 추적은 자동으로 됨**