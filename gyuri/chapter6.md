# 6 전역 상태 관리 라이브러리 소개

## 전역 상태 관리 문제 해결하기

전역 상태를 읽는 방법

- 전역 상태가 바뀌면 리랜더링이 발생하는데, 변경된 값이 컴포넌트와 관련 없는 경우에도 리랜더링이 발생한다. (무슨말이지?)
- 리랜더링 최적화가 필요

전역 상태에 값을 넣거나 갱신하는 방법

- 전역 상태는 여러 값을 가질 수 있다.
- globalVariable.b = 10 이런식으로 값을 변경하면 변경사항을 감지하고 컴포넌트를 리렌더링 할 방법이 없다.
- 변수가 직접 변경 될 수 없도록 클로저를 사용하여 숨길 수도 있다.

```tsx
const createContainer = () => {
  let state = { a: 1, b: 2 };
  const getState = () => state;
  const setState = (newState: typeof state) => {
    state = newState;
  };
  return { getState, setState };
};
```

> 범용 상태관리?
> Redux (단방향 데이터 흐름)
> XState (상태 머신 기반 접근 방식)
> 범용 상태 관리 접근 방식은 전역 상태 뿐만 아니라 지역 상태에도 유용

> Redux와 React는 관련이 없다.
> 리액트와 Redux를 묶는 것이 React-Redux 라이브러리
> Redux에는 리랜더링을 피할 수 있는 방법이 없으니 React-Redux에는 있다.

## 데이터 중심 접근 방식과 컴포넌트 중심 접근 방식 사용하기

### 데이터 중심 접근 방식

데이터 중심 접근 방식은 다음과 같은 특징을 가집니다:

1. 전역 상태를 중앙 집중식으로 관리합니다.
2. 애플리케이션의 모든 데이터를 하나의 큰 객체나 저장소에 보관합니다.
3. 컴포넌트는 필요한 데이터만 선택하여 사용합니다.
4. 상태 변경은 주로 액션을 통해 이루어집니다.
5. Redux나 MobX와 같은 라이브러리가 이 방식을 사용합니다.

장점:

- 데이터 흐름을 추적하기 쉽습니다.
- 상태 관리가 일관성 있게 이루어집니다.
- 디버깅이 용이합니다.

단점:

- 작은 변경에도 보일러플레이트 코드가 많이 필요할 수 있습니다.
- 간단한 애플리케이션에서는 과도한 복잡성을 초래할 수 있습니다.

### 컴포넌트 중심 접근 방식

컴포넌트 중심 접근 방식의 특징은 다음과 같습니다:

1. 상태를 컴포넌트 레벨에서 관리합니다.
2. 필요한 경우에만 상태를 상위 컴포넌트로 끌어올립니다.
3. 컨텍스트(Context)나 props를 통해 상태를 전달합니다.
4. React의 기본적인 상태 관리 방식과 유사합니다.
5. Recoil이나 Jotai와 같은 라이브러리가 이 접근 방식을 확장합니다.

장점:

- 컴포넌트 구조와 밀접하게 연관되어 있어 이해하기 쉽습니다.
- 작은 규모의 애플리케이션에서 빠르게 개발할 수 있습니다.
- 불필요한 보일러플레이트 코드를 줄일 수 있습니다.

단점:

- 애플리케이션이 커지면 상태 관리가 복잡해질 수 있습니다.
- 깊은 컴포넌트 트리에서 props drilling 문제가 발생할 수 있습니다.

| 특성                | 데이터 중심 접근 방식       | 컴포넌트 중심 접근 방식             |
| ------------------- | --------------------------- | ----------------------------------- |
| 상태 관리 위치      | 중앙 집중식 (모듈 상태)     | 분산식 (컴포넌트 상태)              |
| 대표적인 라이브러리 | Redux, MobX                 | React의 useState, Recoil, Jotai     |
| 상태 저장 방식      | 하나의 큰 객체나 저장소     | 개별 컴포넌트 또는 작은 단위의 상태 |
| 데이터 흐름         | 단방향 (Top-down)           | 양방향 가능                         |
| 상태 변경 방법      | 주로 액션을 통해            | 직접적인 상태 업데이트              |
| 확장성              | 대규모 애플리케이션에 적합  | 소규모~중규모 애플리케이션에 적합   |
| 보일러플레이트      | 상대적으로 많음             | 상대적으로 적음                     |
| 디버깅              | 중앙화된 로깅으로 용이      | 컴포넌트별로 복잡할 수 있음         |
| 학습 곡선           | 상대적으로 가파름           | 상대적으로 완만함                   |
| 컴포넌트 재사용성   | 높음 (상태와 분리되어 있음) | 상태에 따라 다를 수 있음            |

## 리렌더링 최적화

### 선택자 함수 사용

선택자 함수는 상태를 받아상태의일부를 반환한다.

수동 렌더링 최적화

```tsx
const Component = 0 => {
  const value = useSelector((state) => state.b.c);
  return <>{value}</>;
};
```

선택자와 메모이제이션에 대한 주요 사항:
선택자 함수가 반환하는 값이 숫자와 같은 원시값이면 문제가 없습니다. 하지만 선택자 함수가 파생된 객체값을 반환하는 경우에는 메모이제이션을 사용해 동일한 객체를 반환하도록 해야 합니다. 메모이제이션에 대해서는 https://en.wikipedia.org/wiki/Memoization을 참고하세요.

### 속성 접근 감지

- 속정 접근을 감지하고 감지한 정보를 렌더링 최적화에 사용할수 있는 상태 사용 추적(state usage tracking)
- useTrackedState 훅

```tsx
const Component = 0 => {
const trackedState = useTrackedStateQ; return <p>{trackedState.b.c}</p>;
};
```

trackedState가.b.c속정에접근했음을감지할수 있고.b.c 속정값이변경될 때만useTrackedState가리렌더링을발생시킨다

자동 렌더링 최적화

#### useSelector와 useTrackedState의 차이점

useSelector는 파생 값을 만들수 있기때문에 상태를 더 간단한 값으로만들수 있다.

```tsx
const Component = 0 => {
const isSmalt = useSelector((state) => state.a < 10); return <>{isSmall. ? 'small' : 'big'}</>;
};
```

```tsx
const Component = 0 => {
const isSmall = useTrackedState().a < 10; return <>{isSmaU. ? 'small' : 'big'}</>;
};
```

useTrackedState는 state.a가 변경될 때 마다 리렌더링된다.
useSelector는 isSmall이 변경될 때만 리렌더링 된다.

### 아톰 사용

아톰은 리렌더링을 발생시키는데 사용되는 최소 상태 단위이다.

```tsx
const globaiState = { a: atom(1),
b: atom(2),
e: atom(3),
};

const Component = 0 => {
const value = useAtom(globalState.a); return o{value}</>;
},

```

아톰과 파생 값의 정의는 명시적이지만 의존성 추적은 자동으로 된다.
