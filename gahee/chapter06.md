# 전역 상태 관리 라이브러리 소개

## 전역 상태 관리 문제 해결하기

전역 상태를 살계할 때 겪을 수 있는 문제점은 다음과 같습니다.

1. 전역 상태를 읽는 방법
   전역 상태를 사용하는 컴포넌트가 모든 전역 상태 값을 필요로 하는 것은 아닙니다. 하지만 전역 상태가 변경되면, 컴포넌트와 직접적으로 관련이 없는 값이 변경되더라도 불필요한 리렌더링이 발생할 수 있습니다. 이로 인해 성능 저하가 일어날 수 있습니다.

2. 전역 상태에 값을 넣거나 갱신하는 방법

```js
let globalVariable = {
  a: 1,
  b: {
    c: 2,
  },
};

globalValriable.b.c = 3;
```

전역 상태는 다양한 값들을 가질 수 있고, 그중 일부는 중첩된 구조일 수 있습니다. 이렇게 하나의 전역 변수를 직접적으로 수정하는 방식은 리액트의 상태 관리 방식과 맞지 않으며, 컴포넌트가 이러한 변경을 감지하고 리렌더링할 방법이 없습니다. 즉, 전역 상태가 변경될 때 이를 감지하기 위해서는 상태 변경을 처리하는 함수가 필요합니다.

## 데이터 증심 접근 방식과 컴포넌트 중심 접근 방식 사용하기

### 데이터 중심 접근 방식

이 방식은 전역 상태를 싱글턴 패턴으로 관리하며, 리액트 컴포넌트 외부에서 상태를 유지합니다. 이렇게 하면 리액트 컴포넌트가 마운트 해제된 후에도 상태가 유지될 수 있습니다. 상태가 리액트 컴포넌트의 생명주기와 독립적으로 관리되므로, 전역 데이터를 필요로 하는 다양한 곳에서 재사용이 용이합니다.

### 컴포넌트 중심 접근 방식

이 접근 방식은 컴포넌트의 생명주기 내에서 전역 상태를 유지하는 것이 적합한 경우에 사용됩니다. 의존하는 컴포넌트가 모두 마운트 해제되면 해당 전역 상태도 함께 사라집니다. 따라서 전역 상태는 컴포넌트 트리에 종속된 상태로 관리됩니다. 이 방식은 컴포넌트 생명주기에 맞춰 상태를 다루는 데 적합합니다.

## 두 접근 방식의 예외

데이터 중심 접근 방식과 컴포넌트 중심 접근 방식을 혼합하여 사용할 수도 있습니다. 예를 들어, 전역 상태를 데이터 중심으로 유지하되, 특정 컴포넌트가 전역 상태를 사용할 때만 동적으로 상태를 가져와서 처리할 수 있습니다.

## 리렌더링 최적화하기

### 선택자 함수 사용 (수동 최적화)

선택자 함수는 전역 상태에서 필요한 부분만 선택해서 사용하는 함수입니다. 상태가 변경되더라도 선택된 부분만 변경된 경우에만 리렌더링이 발생하게 되어 불필요한 렌더링을 막을 수 있습니다.

```
const Component = () => {
  const isSmall = useSelector((state) => state.width < 10);
  return <div>{isSmall ? '작음' : '큼'}</div>;
}
```

이 경우, state.width가 10 이상 또는 미만일 때만 컴포넌트가 리렌더링됩니다.

! 선택자 함수가 파생된 값을 반환할 때는 메모이제이션을 사용하여 동일한 상태에서 항상 동일한 객체를 반환하도록 최적화해야 합니다. 메모이제이션을 통해 변경이 없는 상태에서 불필요한 리렌더링을 방지할 수 있습니다.

### 속성 접근 감지 (자동 최적화)

Proxy 객체를 활용해 상태 객체에 대한 속성 접근을 추적할 수 있습니다. 이를 통해 상태가 변경될 때만 리렌더링을 발생시키는 자동 최적화를 구현할 수 있습니다.
Proxy를 이용해 useTrackedState 훅을 만들어 자동 렌더링 최적화를 구현할 수 있습니다. 

예시로는 Vue의 반응형 시스템이 Proxy를 이용하여 구현되어있습니다. 

#### useSelector와 useTrackedState의 차이점
useTrackedState는 상태의 속성 값이 변경될 때마다 리렌더링이 발생합니다. 반면, useSelector는 상태에서 파생된 값이 변경될 때만 리렌더링을 발생시킵니다.

```js
const Component = () => {
  const isSmall = useSelector((state) => state.width < 10);
  return <div>{isSmall ? "작음" : "큼"}</div>;
};

const Component = () => {
  const isSmall = useTrankedState().a < 10;
  return <div>{isSmall ? "작음" : "큼"}</div>;
};
```
useSelector는 상태의 특정부분을 선택하고 그 선택된 값에 의존된 값(isSmall)의 변경을 추적합니다.
반면, useTrackedState는 Proxy객체에 의해 state.a자체가 감시되거 이 값이 변경되었을때 리렌더링을 발생시킵니다.


### 아톰 사용

**아톰(Atom)**은 리렌더링을 발생시키는 최소 상태 단위입니다. 전역 상태를 관리할 때, 아톰을 사용하면 상태를 더 세밀하게 분리하여 최적화할 수 있습니다. 아톰을 사용하면 명시적으로 상태와 파생값을 정의하고, 의존성 추적을 자동화하여 최적화된 렌더링을 구현할 수 있습니다.

```js
const globalState = {
  a: atom(1),
  b: atom(2),
  c: atom(3),
};

const Component = () => {
  const value = useAtom(globalState.a);
  return <div>{value}</div>;
};
```
ex) recoil이 있다고 합니다. 
이 방식은 수동 최적화와 자동 최적화의 중간 단계를 제공하며, 아톰 단위로 리렌더링을 제어할 수 있습니다.
